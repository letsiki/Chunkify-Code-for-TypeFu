@id custom-b92760dd-0f00-4933-a426-a72f3d78ef5c
@type code
@name Python
@language python
@items
def make_Apowers(max_A, max_x): 
    "A dict of {dict_placeholder_data}."
    exponents = exponents_upto(max_x)
    return {dict_placeholder_data}
def make_Czroots(Apowers): return {dict_placeholder_data}            

# ---

    return 3 if (Cz == C == 1) else int(round(log(Cz, C)))
def tests():
    assert make_Apowers(6, 10) == {dict_placeholder_data}
def beal_modp(max_A, max_x, p=2**31-1):
def make_Apowers_modp(max_A, max_x, p): 
    "A dict of {dict_placeholder_data}."
    exponents = exponents_upto(max_x)
    return {dict_placeholder_data}

# ---

    equations = ((A, B, iroot(A ** n + B ** n, n), n)
                 for A, B in combinations(bases, 2)
                 for n in powers)
    return min(equations, key=relative_error)
def iroot(i, n): 
    "The integer closest to the nth root of i."
    return int(round(i ** (1./n)))

# ---


from __future__ import print_function
import re, sys, types
class Docex:
    def __repr__(self):
        if self.failed:
            return ('<Test:                     % (self.failed, self.passed))
        else:
            return '<Test: passed all %d>' % self.passed

# ---

    def run_class(self, object):
    def run_string(self, teststr):
    def fail(self, teststr, resultstr):
        self.writeln('                     % (resultstr, teststr),
                     '<font color=red><b>', '</b></font>')
        self.failed += 1

# ---

        result = self.already_seen.has_key(id(object))
        self.already_seen[id(object)] = 1
        return result
def main(args):
if __name__ == '__main__':
    main(sys.argv[1:])

from __future__ import print_function
from collections import defaultdict

# ---

    unclustered = set(neighbors)     return [closure(g, set(), unclustered, d, dc)
            for g in neighbors if g in unclustered]
def dist(i, j):
    "Distance between two genomes."
    if i == j: return 0
    return neighbors[min(i, j)].get(max(i, j), max_distance)

# ---

def pct(num, den):
    "Return a string representing the percentage. "
    if '__len__' in dir(den): den = len(den)
    if num==den: return ' 100%'
    return '%.1f%%' % (num*100.0/den)
def showh(d):
    "Show a histogram"
    if not isinstance(d, dict): d = histo(d)
    return ' '.join('%s:%s' % i for i in sorted(d.items()))

# ---

def showc(c):
    return "N=%d, D=%d, M=%d: %s %s" % (
        len(c), diameter(c), margin(c), list(c), showh(species[g] for g in c))
unit_tests()

from __future__ import division
from __future__ import print_function
from collections import Counter, defaultdict

# ---

def histogram(items):
    "Return a Counter of the number of times each key occurs in (key, val) pairs."
    C = Counter()
    for (key, val) in items:
        C[key] += val
    return C
def end(name): return '/' + name

# ---

def row(cells, **kwds):
    return '<tr>' + ''
def ngram_tables(dic, N, pos=[0, 1, 2, 3, 4, -5, -4, -3, -2, -1]):
    L = len(max(D, key=len))
    counts = Counter()
    counts1 = [Counter() for _ in range(L)]
    counts2 = [[Counter() for i in range(L)]]

# ---

def ngrams(word, N):
    return [word[i:i+N] for i in range(len(word)+1-N)]
import glob
def letter_counts(wc):
    result = defaultdict(int)
    for (word, count) in wc.iteritems():
        for p in pieces(word):
            result[p] += count
    return result

# ---

print('start')
print('end')
def test():
    D = {dict_placeholder_data}
def num(ch):
    "Translate 'a' or 'A' to 0, ... 'z' or 'Z' to 25."
    return 'abcdefghijklmnopqrstuvwxyz'.index(ch.lower())
letters = 'ETAOINSRHLDCUMFPGWYBVKXJQZ'
alphabet = ''.join(sorted(letters))

# ---

colors = 'ygobp'
def singleton(x): return [x]
positions = [0, 1, 2, 3, 4, 5, 6, -7, -6, -5, -4, -3, -2, -1]
def substr(word, pos, length):
def ngramcount(D, n=2):
    return histogram((ng, D[w]) for w in D for ng in ngrams(w, n))

# ---

def comma(n): return '{dict_placeholder_data}'.format(n)
def sortedby(D):
    return sorted(D, key=lambda x: -D[x])
ANY = '*'
wordlengths = range(1, 10)
def col(*args): return args
def colname(col):
    fmt = '%s/%s' if (len(col) == 2) else '%s/%d:%d'
    return  fmt % col

# ---

import math
import operator as op
from collections import ChainMap as Environment
def standard_env():
    "An environment with some Scheme standard procedures."
    env = {dict_placeholder_data}
    env.update(vars(math))     env.update({dict_placeholder_data})
    return env

# ---

def parse(program):
    "Read a Scheme expression from a string."
    return read_from_tokens(tokenize(program))
def tokenize(s):
    "Convert a string into a list of tokens."
    return s.replace('(',' ( ').replace(')',' ) ').split()

# ---

import re, sys, io
class Symbol(str): pass
_quote, _if, _set, _define, _lambda, _begin, _definemacro, = map(Sym,
"quote   if   set!  define   lambda   begin   define-macro".split())
_quasiquote, _unquote, _unquotesplicing = map(Sym,
"quasiquote   unquote   unquote-splicing".split())

# ---

quotes = {dict_placeholder_data}
def load(filename):
    "Eval every expression from a file."
    repl(None, InPort(open(filename)), None)
def is_pair(x): return x != [] and isa(x, list)
def cons(x, y): return [x]+y

# ---

global_env = add_globals(Env())
_append, _cons, _let = map(Sym, "append cons let".split())
def expand_quasiquote(x):
macro_table = {dict_placeholder_data} 
eval(parse())
if __name__ == '__main__':
    repl()


# ---

if __name__ == '__main__':
    from lis import *
    test(lis_tests, 'lis.py')
    from lispy import *
    test(lis_tests+lispy_tests, 'lispy.py')

from __future__ import print_function
import re, string, random, glob, operator, heapq
from collections import defaultdict
from math import log10

# ---

    import doctest
    print('Running tests...')
    doctest.testfile('ngrams-test.txt', verbose=verbose)
def splits(text, L=20):
    "Return a list of all possible (first, rem) pairs, len(first)<=L."
    return [(text[:i+1], text[i+1:]) 
            for i in range(min(len(text), L))]

# ---

def product(nums):
    "Return the product of a sequence of numbers."
    return reduce(operator.mul, nums, 1)
def datafile(name, sep='\t'):
    "Read key,value pairs from file."
    for line in file(name):
        yield line.split(sep)

# ---

N = 1024908267229 
Pw  = Pdist(datafile('count_1w.txt'), N, avoid_long_words)
def cPw(word, prev):
    "Conditional probability of word, given previous word."
    try:
        return P2w[prev + ' ' + word]/float(Pw[prev])
    except KeyError:
        return Pw(word)

# ---

def combine(Pfirst, first, Prem__rem): 
    "Combine first and rem results into one (probability, words) pair."
    (Prem, rem) = Prem__rem
    return Pfirst+Prem, [first]+rem
def encode(msg, key): 
    "Encode a message with a substitution cipher." 
    return msg.translate(string.maketrans(ul(alphabet), ul(key))) 

# ---

alphabet = 'abcdefghijklmnopqrstuvwxyz' 
def shift(msg, n=13): 
    "Encode a message with a shift (Caesar) cipher." 
    return encode(msg, alphabet[n:]+alphabet[:n]) 
def logPwords(words): 
    "The Naive Bayes probability of a string or sequence of words." 
    if isinstance(words, str): words = allwords(words) 
    return sum(log10(Pw(w)) for w in words) 

# ---

def shift2(msg, n=13): 
    "Encode with a shift (Caesar) cipher, yielding only letters [a-z]." 
    return shift(just_letters(msg), n) 
def just_letters(text): 
    "Lowercase text and remove all characters except [a-z]." 
    return re.sub('[^a-z]', '', text.lower()) 

# ---

def ngrams(seq, n):
    "List all the (overlapping) ngrams in a sequence."
    return [seq[i:i+n] for i in range(1+len(seq)-n)]
debugging = False 
def shuffled(seq): 
    "Return a randomly shuffled copy of the input sequence." 
    seq = list(seq) 
    random.shuffle(seq) 
    return seq 

# ---

def corrections(text): 
    "Spell-correct all words in text." 
    return re.sub('[a-zA-Z]+', lambda m: correct(m.group(0)), text) 
p_spell_error = 1./20. 
PREFIXES = set(w[:i] for w in Pw for i in range(len(w) + 1)) 


# ---

def is_palindrome(phrase):
    "Test if a phrase is a palindrome."
    cphrase = canonical(phrase)
    return cphrase == reverse(cphrase)
def canonical(word, sub=re.compile('[^A-Za-z0-9]').sub):
    "The canonical form for comparing: lowercase alphanumerics."
    return sub('', word).lower()

# ---

class PalDict:
    def __init__(self, fw=None, bw=None, truename=None):
        update(self, fw=fw or _fw, bw=bw or _bw, truename=truename or _truename)
    def startswith(self, prefix, k=100):
        return k_startingwith(k, self.fw, prefix)

# ---

        return k_startingwith(k, self.bw, suffix)
def k_startingwith(k, words, prefix):
    def missing(self, k=20):
    def __len__(self):
        return len(self.left) + len(self.right)
def reverse(x):
    "Reverse a list or string."
    if type(x) == type(''):
        return ''.join(reverse(list(x)))
    else:
        x.reverse()
        return x

# ---

from __future__ import print_function
import random, re, bisect, time
try:
    xrange          except NameError:
    xrange = range  
def is_panama(s):
    "Test if string s is a Panama-ish palindrome."
    return is_palindrome(s) and is_unique(phrases(s))

# ---

def phrases(s):
    "Break a string s into comma-separated phrases."
    return [phrase.strip() for phrase in s.split(',')]
def canonical(word, sub=re.compile('''[-* \t\n\r.,;!?:()`"']''').sub):
    "The canonical form for comparing: lowercase, no blanks or punctuation."
    return sub('', word).lower()

# ---

def is_unique(seq):
    "Return true if seq has no duplicate elements."
    return len(seq) == len(set(seq))
def update(obj, **entries):
    "Change attributes of obj, according to the keyword args."
    obj.__dict__.update(entries)
    return obj

# ---

    def startswith(self, prefix):
        return self._k_startingwith(self.words, prefix)
    def endswith(self, rsuffix):
        return map(reversestr, self._k_startingwith(self.rwords, rsuffix))
    def __contains__(self, word):
        return word in self.truename

# ---

    def consider_candidates(self):
    def __len__(self):
        return len(self.left) + len(self.right)
factor = {dict_placeholder_data}
if __name__ == '__main__': 
    p = Panama();
    tests(p)
    p.search()


# ---

class PhraseDict(dict):
def prefixes(phrase): return [phrase[:i] for i in range(1, len(phrase) + 1)]
def suffixes(phrase): return [phrase[-i:] for i in range(1, len(phrase) + 1)]
def letters(phrase, sub=re.compile(r'[\W]+').sub):
    "Remove all the non-letters from phrase; return lowercase version."
    return sub('', phrase).lower()

# ---

class Panama:
    def __str__(self): return self.original_phrases(self.best)
    def original_phrases(self, phrases): return ', '.join(self.dict[phrase] for phrase in phrases)
    def search(self, steps=10**5):

# ---

        return actions
    def is_allowed(self, phrase): return phrase in self.dict and phrase not in self.set
alphabet    = 'abcdefghijklmnopqrstuvwxyz'
cat         = ''.join
UndoCommand = str
DoCommand   = list

# ---

from __future__ import print_function
grammar = {dict_placeholder_data}
def mklist(x):
    if type(x) == type([]): return x
    else: return [x]
def match(forest, rhs):
    for i in range(len(rhs)):
        if category(forest[i]) != rhs[i] and forest[i] != rhs[i]: return 0
    return 1

# ---

import re, string, time, os
try:
    cmp             except NameError:
    def cmp(x, y):          return (x > y) - (x < y)
def modulelink(module, baseurl=''):
    if module+'.py' not in local_files:
        baseurl = 'http://www.python.org/doc/current/lib/module-'
    return link(baseurl+module+'.html', module)

# ---

def num_cmp(x, y):
    def num(x):
        nums = re.findall('[0-9]+', x or '')
        if nums: return int(nums[0])
        return x
    return cmp(num(x[0]), num(y[0]))
def comment(text): return i(color("green", text))

# ---


notebooks = {dict_placeholder_data}
python_files = [list_data]    
def cols(items) -> str: "Make columns"; return '|' + '|'.join(items) + '|'
def table(headers, lines) -> str: 
    return f'\n\n{dict_placeholder_data}\n{dict_placeholder_data}\n' + '\n'.join(lines)

# ---

    find_recent(notebooks)
    return '\n'.join(format_category(name) for name in notebooks)
def find_recent(notebooks) -> None:
def format_category(category) -> str:
    print(f'{dict_placeholder_data} notebooks in {dict_placeholder_data}')
    return table(('Run', 'Year', category),
                 [format_notebook(*line) for line in notebooks[category]])

# ---

def format_pythons() -> str:
    print(f'{dict_placeholder_data} pyfiles')
    return table(('File', 'Description', 'Documentation'),
                 [format_python(*line) for line in python_files])
def format_python(url, description, doc='') -> str:

# ---

body = f
output = 'README.md'
print(f'Wrote {dict_placeholder_data} characters to {dict_placeholder_data}')

import random
import collections 
import itertools 
CARDS = [number + color + shade + symbol 
         for number in '123' 
         for color  in 'RGP' 
         for shade  in '@O=' 
         for symbol in '0SD']

# ---

def find_set(layout):
    "Return a set found from this layout, if there is one."
    for cards in itertools.combinations(layout, 3):
        if is_set(cards):
            return cards
    return ()
def Tallies(): 
    "A data structure to keep track, for each size, the number of sets and no-sets."
    return collections.defaultdict(lambda: {dict_placeholder_data})

# ---

def tally_initial_layout_no_prior_sets(N, sizes=(12, 15)):
test()
experiments(100000)

import re
from collections import Counter
def words(text): return re.findall(r'\w+', text.lower())
WORDS = Counter(words(open('big.txt').read()))

# ---

def correction(word): 
    "Most probable spelling correction for word."
    return max(candidates(word), key=P)
def candidates(word): 
    "Generate possible spelling corrections for word."
    return (known([word]) or known(edits1(word)) or known(edits2(word)) or [word])

# ---

def edits2(word): 
    "All edits that are two edits away from `word`."
    return (e2 for e1 in edits1(word) for e2 in edits1(e1))
if __name__ == '__main__':
    print(unit_tests())
    spelltest(Testset(open('spell-testset1.txt')))
    spelltest(Testset(open('spell-testset2.txt')))


# ---

def parse_grid(grid):
        values = dict((s, digits) for s in squares)
    for s,d in grid_values(grid).items():
        if d in digits and not assign(values, s, d):
            return False     return values

# ---

    other_values = values[s].replace(d, '')
    if all(eliminate(values, s, d2) for d2 in other_values):
        return values
    else:
        return False
def eliminate(values, s, d):
def solve(grid): return search(parse_grid(grid))

# ---

def solve_all(grids, name=''):
def time_solve(grid):
    start = time.clock()
    values = solve(grid)
    t = time.clock()-start
    return (t, solved(values))
if __name__ == '__main__':
    test()
    solve_all(open("sudoku-easy50.txt"), "easy")
    solve_all(open("sudoku-top95.txt"), "hard")
    solve_all(open("sudoku-hardest.txt"), "hardest")

# ---

acc_re = re.compile("[[](.+):(.+) for (.+) in (.+)[]]")
def expand_accumulations(program_text):
    def _(matchobj):
        (acc, exp, x, it) = matchobj.groups()
        return "accumulation(%s, lambda %s: (%s), %s)" % (acc, x, exp, it)
    return acc_re.sub(_, program_text)

# ---

    print('temp = ', temp)
    print('data = temp')
    print('votes = ', votes)
    print('candidates = ', candidates)
    print()
if __name__ == "__main__":
    test()


from __future__ import print_function

# ---

class Copier:
    "Smart-copier (YAPTU) class"
    def copyblock(self, i=0, last=None):
        "Main copy method: process lines [i,last) of block"


# ---